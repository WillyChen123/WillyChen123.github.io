{"meta":{"title":"Willy's Blog","subtitle":"","description":"Willy's Blog是個人架設的Blog，主要記錄一些程式、心得及學習筆記。","author":"Willy Chen","url":"http://www.willychen.org","root":"/"},"pages":[{"title":"所有分類","date":"2021-09-24T12:06:51.569Z","updated":"2021-09-24T11:58:20.900Z","comments":true,"path":"categories/index.html","permalink":"http://www.willychen.org/categories/index.html","excerpt":"","text":""},{"title":"關於","date":"2018-01-03T12:40:29.000Z","updated":"2021-09-24T16:36:33.388Z","comments":false,"path":"about/index.html","permalink":"http://www.willychen.org/about/index.html","excerpt":"","text":"作者Willy ChenGithub:https://github.com/WillyChen123 國中時透過校內社團開始接觸 C 語言高中參與資訊社，粗略學習 Java、Python、HTML+CSS+JS目前主要研究Computer Vision相關領域 聲明本站之文章僅為個人淺見，不保證資訊之正確性等，請小心食用若有指教或是發現錯誤等，請留言或寄信至&#x77;&#105;&#x6c;&#108;&#121;&#64;&#x77;&#x69;&#108;&#108;&#x79;&#99;&#x68;&#x65;&#x6e;&#x2e;&#x6f;&#114;&#103;，謝謝！ 網站紀事2019.09.16 網站改用 Hexo 框架2018.05.27 更新 Privacy Policy2018.01.01 網站使用 wordpress 架設完成2018.01.01 Domain Name 設定完成"},{"title":"404 Not Found","date":"2021-09-24T12:06:51.569Z","updated":"2021-09-24T11:58:20.678Z","comments":true,"path":"404.html","permalink":"http://www.willychen.org/404.html","excerpt":"","text":"404 Not Found **很抱歉，您訪問的頁面不存在**"},{"title":"所有標籤","date":"2021-09-24T12:06:51.568Z","updated":"2021-09-24T11:58:20.901Z","comments":true,"path":"tags/index.html","permalink":"http://www.willychen.org/tags/index.html","excerpt":"","text":""},{"title":"Privacy Policy","date":"2018-05-27T07:29:38.000Z","updated":"2021-09-24T11:58:20.901Z","comments":false,"path":"privacy-policy/index.html","permalink":"http://www.willychen.org/privacy-policy/index.html","excerpt":"","text":"This Privacy Policy governs the manner in which Willy’s Blog collects, uses, maintains and discloses information collected from users (each, a “User”) of the http://www.willychen.org website (“Site”). Personal identification informationWe may collect personal identification information from Users in a variety of ways, including, but not limited to, when Users visit our site, register on the site, place an order, fill out a form, respond to a survey, and in connection with other activities, services, features or resources we make available on our Site. Users may be asked for, as appropriate, name, email address. Users may, however, visit our Site anonymously. We will collect personal identification information from Users only if they voluntarily submit such information to us. Users can always refuse to supply personally identification information, except that it may prevent them from engaging in certain Site related activities. Non-personal identification informationWe may collect non-personal identification information about Users whenever they interact with our Site. Non-personal identification information may include the browser name, the type of computer and technical information about Users means of connection to our Site, such as the operating system and the Internet service providers utilized and other similar information. Web browser cookiesOur Site may use “cookies” to enhance User experience. User’s web browser places cookies on their hard drive for record-keeping purposes and sometimes to track information about them. User may choose to set their web browser to refuse cookies, or to alert you when cookies are being sent. If they do so, note that some parts of the Site may not function properly. How we use collected informationWilly’s Blog may collect and use Users personal information for the following purposes: To run and operate our Site We may need your information display content on the Site correctly. To improve customer service Information you provide helps us respond to your customer service requests and support needs more efficiently. To personalize user experience We may use information in the aggregate to understand how our Users as a group use the services and resources provided on our Site. To improve our Site We may use feedback you provide to improve our products and services. To run a promotion, contest, survey or other Site feature To send Users information they agreed to receive about topics we think will be of interest to them. To send periodic emails We may use the email address to send User information and updates pertaining to their order. It may also be used to respond to their inquiries, questions, and/or other requests. How we protect your informationWe adopt appropriate data collection, storage and processing practices and security measures to protect against unauthorized access, alteration, disclosure or destruction of your personal information, username, password, transaction information and data stored on our Site. Sharing your personal informationWe do not sell, trade, or rent Users personal identification information to others. We may share generic aggregated demographic information not linked to any personal identification information regarding visitors and users with our business partners, trusted affiliates and advertisers for the purposes outlined above. We may use third party service providers to help us operate our business and the Site or administer activities on our behalf, such as sending out newsletters or surveys. We may share your information with these third parties for those limited purposes provided that you have given us your permission. Electronic newslettersIf User decides to opt-in to our mailing list, they will receive emails that may include company news, updates, related product or service information, etc. We may use third party service providers to help us operate our business and the Site or administer activities on our behalf, such as sending out newsletters or surveys. We may share your information with these third parties for those limited purposes provided that you have given us your permission. Third party websitesUsers may find advertising or other content on our Site that link to the sites and services of our partners, suppliers, advertisers, sponsors, licensors and other third parties. We do not control the content or links that appear on these sites and are not responsible for the practices employed by websites linked to or from our Site. In addition, these sites or services, including their content and links, may be constantly changing. These sites and services may have their own privacy policies and customer service policies. Browsing and interaction on any other website, including websites which have a link to our Site, is subject to that website’s own terms and policies. Compliance with children’s online privacy protection actProtecting the privacy of the very young is especially important. For that reason, we never collect or maintain information at our Site from those we actually know are under 13, and no part of our website is structured to attract anyone under 13. Changes to this privacy policyWilly’s Blog has the discretion to update this privacy policy at any time. When we do, we will post a notification on the main page of our Site, revise the updated date at the bottom of this page. We encourage Users to frequently check this page for any changes to stay informed about how we are helping to protect the personal information we collect. You acknowledge and agree that it is your responsibility to review this privacy policy periodically and become aware of modifications. Your acceptance of these termsBy using this Site, you signify your acceptance of this policy. If you do not agree to this policy, please do not use our Site. Your continued use of the Site following the posting of changes to this policy will be deemed your acceptance of those changes. This privacy policy was built with the https://PrivacyPolicies.com generator. Contacting usIf you have any questions about this Privacy Policy, the practices of this site, or your dealings with this site, please contact us. The following policies are related to some plugins and other third parties. Disqus CommentsWe use Disqus Comments widget at our website for you to be able to comment at our webpages using Disqus commenting system. Disqus may collect information about you when you register for and use the Service. Such information may include “Personally Identifiable Information” which means information that identifies you as an individual, such information may include, but is not limited to, your name, email address, telephone number, username or account ID, and “Non-Personally Identifiable Information” which means information that does not identify you as an individual. Non-Personally Identifiable Information may include, but is not limited to, information about your browser, your IP address, device ID, what pages you visit on our Partner Sites, which website you came from, what advertisements you clicked on, whether on our Partner Websites, the Service or other third party websites, and other information about your online activity that does not identify you as an individual, in accordance with their data privacy policy: https://help.disqus.com/terms-and-policies/disqus-privacy-policy Facebook Like, Facebook Recommend, Facebook Share official buttonsWe embed a Facebook widget to allow you to see number of likes/shares/recommends and “like/share/recommend” our webpages. This widget may collect your IP address, your web browser User Agent, store and retrieve cookies on your browser, embed additional tracking, and monitor your interaction with the widget, including correlating your Facebook account with whatever action you take within the widget (such as “liking/sharing/recommending” our webpage), if you are logged in to Facebook. For more information about how this data may be used, please see Facebook’s data privacy policy: https://www.facebook.com/about/privacy/update Twitter Tweet official buttonWe use a Twitter Tweet widget at our website. As a result, our website makes requests to Twitter’s servers for you to be able to tweet our webpages using your Twitter account. These requests make your IP address visible to Twitter, who may use it in accordance with their data privacy policy: https://twitter.com/en/privacy#update GooglePlus, GooglePlus Share official buttonsWe use a GooglePlus widget at our website. As a result, our website makes requests to Google’s servers for you to be able to share our webpages using your GooglePlus account. These requests make your IP address visible to Google, who may use it in accordance with their data privacy policy: https://policies.google.com/privacy Reddit Badge official buttonWe use Reddit Badge widget at our website which may log information when you interact with the widget. This may include your IP address, user-agent string, browser type, operating system, referral URLs, device information (e.g., device IDs), pages visited, links clicked, user interactions (e.g., voting data), the requested URL and hardware settings, in accordance with their privacy policy: https://www.redditinc.com/policies/privacy-policy CloudFlareWe use CloudFlare CDN to improve the user experience and security of our site. All data passed to or from our website pass through the worldwide network of CloudFlare. For more information, please review Cloudflare’s privacy policy : https://www.cloudflare.com/privacypolicy This document was last updated on May 27, 2018"},{"title":"作品","date":"2018-01-02T05:57:07.000Z","updated":"2021-09-24T16:33:59.380Z","comments":false,"path":"works/index.html","permalink":"http://www.willychen.org/works/index.html","excerpt":"","text":"Submit Status2017.11 Web學習簡單使用Beautiful Soup 4的爬蟲功能統計各個作業的分數狀況Demo Note2016.01 Android App在四校聯合寒訓時，課程教材中實作的記事本Github Calculator2015.12 Android App在資訊社社課上簡單實作計算機Github 2015 楓琴建譜2015.06 Web2015年暑假與楓資合辦暑訓與資訊社學術幹部一同架設宣傳網站Demo DrinkOrder2014.11 Web因為班上常訂飲料，統計的人員很辛苦因此試做網站來統計每位使用者的飲料方便統計的人向飲料商店訂購Github"}],"posts":[{"title":"UVa 679 - Dropping Balls","slug":"uva-679-dropping-balls","date":"2019-09-29T17:48:06.000Z","updated":"2021-09-24T16:43:33.128Z","comments":true,"path":"450/uva-679-dropping-balls/","link":"","permalink":"http://www.willychen.org/450/uva-679-dropping-balls/","excerpt":"題目簡述 有一個滿二元樹，題目會多次的從樹根放球往下掉 每個節點都有一個標記，一開始初始值是往左，當有一顆球經過時，就會切換成右，再有一顆球經過，就切換成左，以此類推 當一顆球來到一個節點，依照標記來決定要往左子樹走，還是右子樹走，來走到下一層 一顆球走到最下面那層，就會有最後停下來的那個節點編號，然後就可以從樹根放下一顆球","text":"題目簡述 有一個滿二元樹，題目會多次的從樹根放球往下掉 每個節點都有一個標記，一開始初始值是往左，當有一顆球經過時，就會切換成右，再有一顆球經過，就切換成左，以此類推 當一顆球來到一個節點，依照標記來決定要往左子樹走，還是右子樹走，來走到下一層 一顆球走到最下面那層，就會有最後停下來的那個節點編號，然後就可以從樹根放下一顆球 題目會給定最大深度 $D$ 和總共放了 $I$ 顆球 輸出第 $I$ 顆球最後會停在哪個節點 解題想法 可以開一個陣列存二元樹，然後依序模擬每一顆球往下掉的過程和結果，最後輸出答案，不過這樣可能會 TLE 若是可以給定第 $I$ 顆球，直接計算就會快很多 想法 若是數字是奇數，那應該往左走，若是偶數則往右走 每往下走一層，數字應該要除以二 所以就用一個 for 迴圈掃過每一層，然後每一層決定要往左走還是往右走 注意若此節點編號為 $N$，則下一層左邊節點編號為 $2N$，右邊節點編號為 $2N+1$ 程式碼123456789101112131415161718192021222324252627282930/***************************************** Filename:p679.cpp Author:Willy Chen(willychen.org) Date:2019.09.30*****************************************/#include&lt;iostream&gt;using namespace std;int main()&#123; int kase; cin &gt;&gt; kase; while(kase--)&#123; int D, I; cin &gt;&gt; D &gt;&gt; I; int now = 1, remain = I; for(int i = 1; i &lt; D; ++i)&#123; if(remain % 2 == 1)&#123; // Left now = 2 * now; remain = (remain + 1) / 2; &#125;else&#123; // Right now = 2 * now + 1; remain = remain / 2; &#125; &#125; cout &lt;&lt; now &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"},{"name":"Data Structure","slug":"data-structure","permalink":"http://www.willychen.org/tags/data-structure/"},{"name":"Binary Tree","slug":"binary-tree","permalink":"http://www.willychen.org/tags/binary-tree/"},{"name":"Full Binary Tree","slug":"full-binary-tree","permalink":"http://www.willychen.org/tags/full-binary-tree/"}]},{"title":"UVa 1207 - AGTC","slug":"uva-1207-agtc","date":"2019-09-22T14:35:42.000Z","updated":"2021-09-24T14:56:18.977Z","comments":true,"path":"421/uva-1207-agtc/","link":"","permalink":"http://www.willychen.org/421/uva-1207-agtc/","excerpt":"題目簡述 輸入兩個字串 x 和 y ，要把字串 x 轉換成字串 y 可以進行的操作步驟是 刪除一個字母 插入一個字母 置換一個字母 輸出最少的操作步驟把字串 x 轉換成字串 y","text":"題目簡述 輸入兩個字串 x 和 y ，要把字串 x 轉換成字串 y 可以進行的操作步驟是 刪除一個字母 插入一個字母 置換一個字母 輸出最少的操作步驟把字串 x 轉換成字串 y 解題想法 這題主要就是建立一個二維陣列，然後想要如何填這個陣列 若我們定義 $C_{i, j}$ 是從字串 $a_i$ 到 $b_j$ 的最小操作數量，則 $C_{i, j}$ 的規則如下 $$C_{i, j}=min \\begin{cases} C_{i-1, j}+1&amp;&amp;刪除a_j\\\\ C_{i, j-1}+1&amp;&amp;插入b_j\\\\ C_{i-1, j-1}+d_{i, j}&amp;&amp;置換\\\\ \\end{cases}$$ $$d_{i, j}= \\begin{cases} 0&amp;&amp;if\\ \\ a_i=b_j\\\\ 1&amp;&amp;if\\ \\ a_i\\neq b_j\\\\ \\end{cases}$$ 例如字串 A 為 “abbc”, 字串 B 為 “babb”，最後陣列會是這個樣子 以上面框起來的那格 $C_{2,2}$ 來說，這格可以從… 左方（$C_{2,1}$）過來（插入）：A字串插入 $b_2$ 上方（$C_{1,2}$）過來（刪除）：A字串刪除 $a_2$ 左上方（$C_{1,1}$）過來（置換）：A字串置換 $a_2$ 成 $b_2$ 注意置換的 $d_{i, j}$ ，若是 $a_2$ 等於 $b_2$ ，那其實就不用置換了（因為兩個字母相同），若是不相等，那就需要進行置換的動作 然後找最小值，所以數值為 2 所以把整個陣列填完後，最後最小的路徑為以下這樣，最小操作步驟為 2 步 最後補充一下，初始化的數值是陣列 $ a_0 $ 和 $ b_0 $ 的那一行/列 ，其數值是從 0 開始依序往上加 1 ，可以思考一下原因 程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445/***************************************** Filename:p1207.cpp Author:Willy Chen(willychen.org) Date:2019.09.22*****************************************/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;/* Find the minimum value */int find_min(int a, int b, int c)&#123; int ans = a; if(b &lt; ans) ans = b; if(c &lt; ans) ans = c; return ans;&#125;int main()&#123; char s1[1000], s2[1000]; int num1, num2; while(scanf(&quot;%d%s&quot;, &amp;num1, &amp;s1[1]) != EOF)&#123; scanf(&quot;%d%s&quot;, &amp;num2, &amp;s2[1]); int graph[1000][1000]=&#123;0&#125;; /* Initialize the graph */ for(int i = 0; i &lt; 1000; ++i)&#123; graph[0][i]=i; graph[i][0]=i; &#125; for(int i = 1; i &lt;= num1; ++i)&#123; for(int j = 1; j &lt;= num2; ++j)&#123; /* Replace operation */ int num_re = graph[i-1][j-1]; if(s1[i] != s2[j]) num_re++; /* Find the minimum number of operations */ graph[i][j] = find_min(num_re, graph[i-1][j]+1, graph[i][j-1]+1); &#125; &#125; cout &lt;&lt; graph[num1][num2] &lt;&lt; endl; &#125; return 0 ;&#125;","categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"},{"name":"Algorithm","slug":"algorithm","permalink":"http://www.willychen.org/tags/algorithm/"},{"name":"Longest Common Subsequence","slug":"longest-common-subsequence","permalink":"http://www.willychen.org/tags/longest-common-subsequence/"},{"name":"Edit Distance","slug":"edit-distance","permalink":"http://www.willychen.org/tags/edit-distance/"}]},{"title":"UVa 1056 - Degrees of Separation","slug":"uva-1056-degrees-of-separation","date":"2019-09-18T17:14:15.000Z","updated":"2021-09-24T14:52:20.600Z","comments":true,"path":"420/uva-1056-degrees-of-separation/","link":"","permalink":"http://www.willychen.org/420/uva-1056-degrees-of-separation/","excerpt":"題目簡述 現在有多個人，任意兩個人可能有直接關係，或是沒有直接關係 依序輸入兩個人的名字，代表這兩個人是有直接關係的 要求輸出最大有幾度分隔(maximum degree of separation)(任意選兩個人，他們的間隔一定會不大於輸出的答案) 若是可以找到兩個人中間沒有間隔(就是沒有間接關係)，輸出”DISCONNECTED”","text":"題目簡述 現在有多個人，任意兩個人可能有直接關係，或是沒有直接關係 依序輸入兩個人的名字，代表這兩個人是有直接關係的 要求輸出最大有幾度分隔(maximum degree of separation)(任意選兩個人，他們的間隔一定會不大於輸出的答案) 若是可以找到兩個人中間沒有間隔(就是沒有間接關係)，輸出”DISCONNECTED” 解題想法 這是一題 All-Pairs Shortest Path 的題目 使用 Floyd-Warshall 演算法來解題 Floyd-Warshall 演算法 $$D_{i, j, k-1}=min\\begin{cases}D_{i, j, k-1}\\\\D_{i, k, k-1}+D_{k, j, k-1}\\end{cases}$$ 當要從點 i 走到點 j 時，要不就是從 i 走到 j， i → j ，要不就是經過一個點 k， i → k → j 這個演算法主要是用三層迴圈實作123456789101112/* Floyd-Warshall Algorithm */for(int k = 0; k &lt; P; ++k)&#123; for(int i = 0; i &lt; P; ++i)&#123; for(int j = 0; j &lt; P; ++j)&#123; int dis = remap[i][k] + remap[k][j]; if(dis &lt; remap[i][j] &amp;&amp; i != j &amp;&amp; i != k &amp;&amp; j != k)&#123; remap[i][j] = dis; remap[j][i] = dis; &#125; &#125; &#125;&#125; 最外層的 k 是掃過所有的中繼點，然後分別掃描每個點 i 到點 j 的距離 最裡面的 dis 先計算 i → k → j 的距離，然後和原本 i → j 的距離比較，選較小的那個存起來 程式碼12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/***************************************** Filename:p1056.cpp Author:Willy Chen(willychen.org) Date:2019.09.19*****************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int main()&#123; int P, R; int kase = 0; while(1)&#123; cin &gt;&gt; P &gt;&gt; R; if(P == 0 &amp;&amp; R == 0)&#123; break; &#125; string name1, name2; int ids = 0; map&lt;string, int&gt; name2id; int remap[50][50] = &#123;0&#125;; for(int i = 0; i &lt; 50; ++i) for(int j = 0; j &lt; 50; ++j) remap[i][j] = 100000; /* Read relations and create graph */ for(int i = 0; i &lt; R; ++i)&#123; cin &gt;&gt; name1 &gt;&gt; name2; int id1, id2; map&lt;string, int&gt;::iterator re = name2id.find(name1); if(re == name2id.end())&#123; name2id[name1] = ids++; &#125; id1 = name2id[name1]; re = name2id.find(name2); if(re == name2id.end())&#123; name2id[name2] = ids++; &#125; id2 = name2id[name2]; /* Create adjacency matrix */ remap[id1][id2] = 1; remap[id2][id1] = 1; &#125; /* Floyd-Warshall Algorithm */ for(int k = 0; k &lt; P; ++k)&#123; for(int i = 0; i &lt; P; ++i)&#123; for(int j = 0; j &lt; P; ++j)&#123; int dis = remap[i][k] + remap[k][j]; if(dis &lt; remap[i][j] &amp;&amp; i != j &amp;&amp; i != k &amp;&amp; j != k)&#123; remap[i][j] = dis; remap[j][i] = dis; &#125; &#125; &#125; &#125; int ans = 0; /* Get the maximum value */ for(int i = 0; i &lt; P; ++i)&#123; for(int j = 0; j &lt; P; ++j)&#123; if(i != j &amp;&amp; remap[i][j] == 100000)&#123; ans = -1; continue; &#125; if(remap[i][j] != 100000 &amp;&amp; ans != -1 &amp;&amp; ans &lt; remap[i][j])&#123; ans = remap[i][j]; &#125; &#125; &#125; kase++; if(ans == -1)&#123; printf(&quot;Network %d: DISCONNECTED\\n\\n&quot;, kase); &#125;else&#123; printf(&quot;Network %d: %d\\n\\n&quot;, kase, ans); &#125; &#125; return 0;&#125;","categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"},{"name":"Algorithm","slug":"algorithm","permalink":"http://www.willychen.org/tags/algorithm/"},{"name":"Dynamic Programming","slug":"dynamic-programming","permalink":"http://www.willychen.org/tags/dynamic-programming/"},{"name":"All-Pairs Shortest Path","slug":"all-pairs-shortest-path","permalink":"http://www.willychen.org/tags/all-pairs-shortest-path/"},{"name":"Floyd–Warshall algorithm","slug":"floyd–warshall-algorithm","permalink":"http://www.willychen.org/tags/floyd%E2%80%93warshall-algorithm/"}]},{"title":"UVa 10810 - Ultra-QuickSort","slug":"uva-10810-ultra-quick-sort","date":"2019-09-17T06:15:38.000Z","updated":"2021-09-24T14:53:25.637Z","comments":true,"path":"416/uva-10810-ultra-quick-sort/","link":"","permalink":"http://www.willychen.org/416/uva-10810-ultra-quick-sort/","excerpt":"題目簡述 輸入一串數字，要把其從小到大排列 每個數字可以和其左右鄰居的數字進行交換 輸出最少的交換次數，讓這串數字排列好","text":"題目簡述 輸入一串數字，要把其從小到大排列 每個數字可以和其左右鄰居的數字進行交換 輸出最少的交換次數，讓這串數字排列好 解題想法 使用Bubble Sort來實作，只要計算左右數字交換了幾次，然後輸出答案就可以了，但是因為時間複雜度是 $O(n^2)$ ，非常有可能會TLE 這題的題目雖然命名為Quick Sort，但實際上是用Merge Sort來排序 使用Merge Sort來實作，時間複雜度是 $O(nlogn)$ ，再來就是想怎麼計算交換次數了 考慮以下Merge時的狀況： Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 假設 Index 0~2 是左陣列， 3~5 是右陣列 第一輪因為 value 2 是最小的，因此不用動 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 第二輪右陣列的 value 3 是最小的，因此要往左交換（換句話說， value 5 和 6 會往後排），要交換的次數就是左陣列剩下還沒排的2個數字， counter=2 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 3 第三輪右陣列的 value 4 是最小的，因此要往左交換，要交換的次數就是左陣列剩下還沒排的2個數字， counter=2+2=4 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 3 4 第四輪左陣列的 value 5 是最小的，因此不需要進行交換，直接放進去， counter=4 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 3 4 5 第五輪左陣列的 value 6 是最小的，因此不需要進行交換，直接放進去， counter=4 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 3 4 5 6 第六輪右陣列的 value 7 是最小的，但是因為左陣列已經沒數字了，因此不需要進行交換，直接放進去， counter=4 Index 0 1 2 3 4 5 Value 2 5 6 3 4 7 Merge 2 3 4 5 6 7 counter要計算的，就是當Merge時要放右陣列的數字時，counter要加上左陣列剩下數字的數量 所以要做的事情就是實作Merge Sort，然後加上counter計算次數 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/***************************************** Filename:p10810.cpp Author:Willy Chen(willychen.org) Date:2019.09.17*****************************************/#include&lt;iostream&gt;using namespace std;long long int counter;int ans[500005]=&#123;0&#125;;void Merge(int* input, int left, int mid, int right)&#123; int idxl=left,idxr=mid+1; for(int i=0;i&lt;=right-left;++i)&#123; if(idxl&gt;mid)&#123; /* Left array run out */ ans[i]=input[idxr++]; continue; &#125; if(idxr&gt;right)&#123; /* Right array run out */ ans[i]=input[idxl++]; continue; &#125; if(input[idxl]&lt;=input[idxr])&#123; /* Copy left array value */ ans[i]=input[idxl++]; &#125;else&#123; /* Copy right array value */ counter += (mid-idxl+1); ans[i]=input[idxr++]; &#125; &#125; /* Copy to original array */ for(int i=0;i&lt;=right-left;++i)&#123; input[left+i]=ans[i]; &#125;&#125;void mergeSort(int* input, int left, int right)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; /* Split left array */ mergeSort(input, left, mid); /* Split right array */ mergeSort(input, mid+1, right); /* Merge left and right array */ Merge(input, left, mid, right); &#125;&#125;int main()&#123; int kase; while(1)&#123; cin &gt;&gt; kase; if(kase==0) break; else&#123; int input[500005]=&#123;0&#125;; for(int i=0;i&lt;kase;++i)&#123; cin &gt;&gt; input[i]; &#125; counter = 0; mergeSort(input,0,kase-1); cout &lt;&lt; counter&lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Sort","slug":"sort","permalink":"http://www.willychen.org/tags/sort/"},{"name":"Merge Sort","slug":"merge-sort","permalink":"http://www.willychen.org/tags/merge-sort/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"}]},{"title":"2018 政大通識課紀錄 1","slug":"2018-nccu-general-education-1","date":"2018-08-19T00:53:31.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"336/2018-nccu-general-education-1/","link":"","permalink":"http://www.willychen.org/336/2018-nccu-general-education-1/","excerpt":"下學期準備要開始選課了 將這學期修過的通識課程 在這邊記錄下來","text":"下學期準備要開始選課了 將這學期修過的通識課程 在這邊記錄下來 由歷史事件看國際關係 時間：一12 / mon08-10 老師：郭昕光 老師 這堂課開在早八 適合早起的人來選 也因為喜歡早八上課的人相對較少 若是選課沒選到 只要第一堂來加簽 基本上就行了 內容主要是把近百年來國際上發生的戰爭介紹過 上課的方式是每一堂課開始都會小考 要考的內容就是各場戰爭或是人物的一些事情 例如某某戰爭發生在哪一天 或是某某人的母校是哪一所 都是簡答題 一題一分 每次考個十題上下 學期末加起來的分數就是小考成績 很容易超過一百分 考完試後會檢討答案 也會介紹及提到相關的資料 之後剩下的時間就是看影片、紀錄片 伴隨著老師悅耳的聲音 整個課程算是非常輕鬆愉快的 作業的部分 整個學期就是期中交一次影片心得 （沒有規定字數，筆者寫了一千字上下） 然後期末要交一篇四千字的學期報告 有時筆者會跟朋友分享在課程上的所見所聞 算是有所收穫的 國文－現代散文選讀 時間：一D56 / mon13-16 老師：李錦昌 老師 這堂課是同學推薦去的 主要是老師人非常的好 內容如課程名稱 每堂課會有兩至三篇的散文來閱讀 然後課堂上會分組 每組四個人 每次上課會有其中一組的兩個人上台介紹選定的散文 （導讀組，基本上大家都是做 PPT ） 然後會有另外一組的兩個人（討論組） 上台討論剛剛導讀組提到的內容 或是自己對於選定的散文的見解 每次會有四到五個人拿評分表 對於導讀與討論組的報告表達看法及評分 總之就是每個人都會上台一次 每個人都會填一次評分表就是了 接下來老師就開始上課了 整個學期除了一些課堂上的練習 還有一次期中創作練習 電子檔繳交 然後這堂課有期中和期末考 簡答題和申論題 申論題是有幾個題目 每一題裡面會有一些題目 依照題目要求選其中幾個來回答 不過期中占分較低 期末考占分較高 前面提到老師人很好、很客氣 會記得同學的名字 喜歡貓 課程快結束時還請過飲料 非常的 Nice 法學素養 時間：二78E / tue16-19 老師：林佳和 老師 這堂課是社會核心通識 基本上前兩個小時是老師講一些法律相關的知識 還有一些有關的故事 剩下的一個小時討論課會分成四個大組 每一大組會到不同的教室 而每一大組會分成幾個小組 每個小組討論這個禮拜要討論的題目 上課不會點名 只有討論課助教可能會點 不過有次上課人太少 就點名加分了 （印象中好像那天筆者的朋友剛好沒來沒加到分） 整個學期每個月交一次一千字心得報告 總共四次 題目就是這個月討論的議題擇一討論 算是非常輕鬆的作業 這學期選了這三堂通識課 基本上還不錯 美中不足的是和上學期不一樣 由歷史事件看國際關係 和 國文課 都是拉低筆者平均的科目 形成了要用必修來拉高平均的現象…… 這兩科拉低了筆者平均三點多分 可能是筆者太不認真了…… 有點傷心…… 有興趣的可以去選修這些課程","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"心得","slug":"學習筆記/心得","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"NCCU","slug":"nccu","permalink":"http://www.willychen.org/tags/nccu/"}]},{"title":"Computer Programming II Final Exam Problem 4 Letter Case Permutation","slug":"computer-programming-ii-final-exam-problem-4-letter-case-permutation","date":"2018-08-14T15:02:05.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"342/computer-programming-ii-final-exam-problem-4-letter-case-permutation/","link":"","permalink":"http://www.willychen.org/342/computer-programming-ii-final-exam-problem-4-letter-case-permutation/","excerpt":"計算機程式設計2 期末考的題目4題目簡述 輸入一個字串，包含大小寫及數字","text":"計算機程式設計2 期末考的題目4題目簡述 輸入一個字串，包含大小寫及數字 題目輸出 每個字母可以是大寫或是小寫，從小到大輸出所有可能答案 範例 輸入： b1H2e3 輸出： b1h2e3 b1h2E3 b1H2e3 b1H2E3 B1h2e3 B1h2E3 B1H2e3 B1H2E3 解題想法 這題其實是 Leetcode 784. Letter Case Permutation 筆者想到了兩種實作方法 第一種作法就是用遞迴跑出所有答案 123456789101112131415161718192021222324252627282930313233343536373839404142/***************************************** Filename:cp2_final_p4_1.c Author:Willy Chen(willychen.org) Date:2018.08.14*****************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;/* 1:Uppercase 2:Lowercase */int upper(char c)&#123; if(c&gt;=&#x27;A&#x27;&amp;&amp;c&lt;=&#x27;Z&#x27;) return 1; else return 2;&#125;void dfs(char* input,int now,int len)&#123; if(now&gt;=len)&#123; /* Print the answer */ printf(&quot;%s\\n&quot;,input); return; &#125; if(input[now]&gt;=&#x27;0&#x27;&amp;&amp;input[now]&lt;=&#x27;9&#x27;)&#123; /* Number, continue to the next character */ dfs(input,now+1,len); &#125;else&#123; /* Convert to lowercase */ if(upper(input[now])==1) input[now]=input[now]-&#x27;A&#x27;+&#x27;a&#x27;; dfs(input,now+1,len); /* Convert to uppercase */ if(upper(input[now])==2) input[now]=input[now]-&#x27;a&#x27;+&#x27;A&#x27;; dfs(input,now+1,len); &#125;&#125;int main()&#123; char input[105]; while(scanf(&quot;%s&quot;,input)!=EOF)&#123; dfs(input,0,strlen(input)); &#125; return 0;&#125; 第二種作法是維護一個數字陣列放 0 或 1 當數字是 0 時代表小寫 當數字是 1 時代表大寫 這個數字陣列從 0 開始印答案 每次加 1 ，然後印出答案 （簡單來說就是二進位加法的意思） 所以假設有兩個字母 ab 順序就是 00 → 01 → 10 → 11 ab → aB → Ab → AB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/***************************************** Filename:cp2_final_p4_2.c Author:Willy Chen(willychen.org) Date:2018.08.14*****************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char input[105]; while(scanf(&quot;%s&quot;,input)!=EOF)&#123; int len = strlen(input); int lett[105]=&#123;0&#125;; /* -1:number 0:lowercase 1:uppercase */ int alpha=0; /* The number of alphabets */ /* Convert to lowercase */ for(int i=0;i&lt;len;i++)&#123; if(input[i]&gt;=&#x27;A&#x27;&amp;&amp;input[i]&lt;=&#x27;Z&#x27;)&#123; input[i]=input[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; if(input[i]&gt;=&#x27;0&#x27;&amp;&amp;input[i]&lt;=&#x27;9&#x27;)&#123; lett[i]= -1; &#125;else&#123; alpha++; &#125; &#125; /* Calculate the number of lines of strings */ int times=1; for(int i=0;i&lt;alpha;i++)&#123; times *= 2; &#125; /* Print the answer */ while(times--)&#123; /* Print strings */ for(int i=0;i&lt;len;i++)&#123; if(lett[i]==-1)&#123; /* Print number */ printf(&quot;%c&quot;,input[i]); &#125;else if(lett[i]==0)&#123; /* Print lowercase */ printf(&quot;%c&quot;,input[i]); &#125;else&#123; /* Print uppercase */ printf(&quot;%c&quot;,input[i]-&#x27;a&#x27;+&#x27;A&#x27;); &#125; &#125; printf(&quot;\\n&quot;); /* Plus 1 */ for(int i=len-1;i&gt;=0;i--)&#123; if(lett[i]!=-1)&#123; if(lett[i]==0)&#123; lett[i]=1; break; &#125;else&#123; lett[i]=0; continue; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 其實兩種作法的想法算是一樣的 就是要按照順序把答案印出來","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Assignment","slug":"assignment","permalink":"http://www.willychen.org/tags/assignment/"},{"name":"LeetCode","slug":"leetcode","permalink":"http://www.willychen.org/tags/leetcode/"}]},{"title":"Linear Basis For XOR","slug":"linear-basis-for-xor","date":"2018-06-08T03:10:02.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"312/linear-basis-for-xor/","link":"","permalink":"http://www.willychen.org/312/linear-basis-for-xor/","excerpt":"幾天前剛好看到朋友的網誌中提到線性基問題 最近線性代數的課程也提到了 Vector Space 學習一下相關的知識~","text":"幾天前剛好看到朋友的網誌中提到線性基問題 最近線性代數的課程也提到了 Vector Space 學習一下相關的知識~ 參考資料： Linear basis for xor | 睦 线性基学习笔记 | Sengxian’s Blog 邏輯異或 - 維基百科，自由的百科全書 向量空間 - 維基百科，自由的百科全書 线性基_百度百科","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"}],"tags":[{"name":"Basis","slug":"basis","permalink":"http://www.willychen.org/tags/basis/"},{"name":"Linear Algebra","slug":"linear-algebra","permalink":"http://www.willychen.org/tags/linear-algebra/"},{"name":"XOR","slug":"xor","permalink":"http://www.willychen.org/tags/xor/"}]},{"title":"Lenovo 筆電 Fn Key 設定","slug":"lenovo-laptop-fn-key-config","date":"2018-05-27T09:06:54.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"305/lenovo-laptop-fn-key-config/","link":"","permalink":"http://www.willychen.org/305/lenovo-laptop-fn-key-config/","excerpt":"筆者和一位朋友目前都是使用 Lenovo Yoga 系列的筆電 昨天兩人在聊天的時候 朋友提到每次要按快速鍵關視窗很麻煩 都要按 Fn + Alt + F4","text":"筆者和一位朋友目前都是使用 Lenovo Yoga 系列的筆電 昨天兩人在聊天的時候 朋友提到每次要按快速鍵關視窗很麻煩 都要按 Fn + Alt + F4 不過我記得剛購入筆電時 就去 BIOS 修改設定 調成以前習慣的模式 （就是要調亮度之類的要按 Fn，使用 F1~F12不用按 Fn） 以下紀錄一下如何設定～ 注意：以下紀錄資料僅供參考，執行前請記得備份資料 每個 BIOS 的設定位置可能和以下敘述有所差異 按下開機鈕後按 F2 進入 BIOS 按左右鍵移動到 Configuration 的 Tab 按上下鍵移動到 HotKey Mode 選項 按 Enter 後選擇 Disabled Enabled 就是不需按 Fn 就可以調整亮度音量 Disabled 就是需要按 Fn 才可以調整亮度音量 按左右鍵移動到 Exit 的 Tab 選擇 Exit Saving Changes 接下來重新開機後測試看看有無符合預期的效果～","categories":[{"name":"Tips","slug":"tips","permalink":"http://www.willychen.org/categories/tips/"}],"tags":[{"name":"Bios","slug":"bios","permalink":"http://www.willychen.org/tags/bios/"},{"name":"Fn Key","slug":"fn-key","permalink":"http://www.willychen.org/tags/fn-key/"},{"name":"Lenovo Yoga","slug":"lenovo-yoga","permalink":"http://www.willychen.org/tags/lenovo-yoga/"}]},{"title":"關於隱私權政策","slug":"about-privacy-policy","date":"2018-05-27T08:36:20.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"302/about-privacy-policy/","link":"","permalink":"http://www.willychen.org/302/about-privacy-policy/","excerpt":"如同在 關於 中提到的 這個網站僅記錄一些個人的淺見","text":"如同在 關於 中提到的 這個網站僅記錄一些個人的淺見 並沒有插入廣告 也沒有從網站中得到金錢 本網站中使用了一些 Plugins 和第三方服務 如 Disqus 和 Cloudflare 以及使用 Wordpress 會產生一些 Cookies 和 Logs 這個網站主要都是中文的文章 不過無法確定瀏覽者中是否有與歐盟相關的人員 而歐盟的 GDPR 已於2018年5月25日開始生效 這兩天筆者花了十多個小時參閱了一些新聞 以及一些提到有關 GDPR &amp; bloggers 的文章 目前網站上已經更新了由 https://PrivacyPolicies.com generator 產生的 Privacy Policy 以及在後面添加一些第三方服務的 Privacy Policy 連結 這個網站無意違反相關法規 不過畢竟不是專業人士 不確定是否符合相關法規 這網站也不是什麼企業團體要提供服務或販售產品之類的 純粹記錄個人的經驗與淺見而已 若是對於這個網站有任何建議的話 歡迎留言及寄信至&#119;&#105;&#108;&#108;&#x79;&#x40;&#119;&#x69;&#x6c;&#108;&#x79;&#99;&#104;&#101;&#x6e;&#x2e;&#x6f;&#114;&#103; 謝謝~","categories":[{"name":"其他","slug":"其他","permalink":"http://www.willychen.org/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Case Sensitive Search In Vim","slug":"case-sensitive-search-in-vim","date":"2018-05-17T06:07:50.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"272/case-sensitive-search-in-vim/","link":"","permalink":"http://www.willychen.org/272/case-sensitive-search-in-vim/","excerpt":"筆者之前接觸 CTF 的時候 有一題答案是要將一篇文章中的小寫字母刪除 只留下大寫字母","text":"筆者之前接觸 CTF 的時候 有一題答案是要將一篇文章中的小寫字母刪除 只留下大寫字母 筆者將文章貼至 vim 當中 在命令模式 （Command mode）執行以下命令 1:s/\\[a-z]//g 發現大小寫的字母都被刪除了 但是執行 1:s/\\\\l//g 卻只會刪除小寫的字母 查詢資料之後 發現 Vim 有 Case Sensitive 的設定 當執行 1:s/\\[a-z]\\\\C//g （大寫 C ）只會取代小寫字母（Case sensitive） 當執行 1:s/\\[a-z]\\\\c//g （小寫 c ）會取代大小寫字母（Case insensitive） 另外也可以執行 1:set noic 讓所有搜尋都是（Case sensitive） 執行 1:set ic 讓所有搜尋都是（Case insensitive） 資料參考來源：How to do case insensitive search in Vim","categories":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"},{"name":"Tips","slug":"linux/tips","permalink":"http://www.willychen.org/categories/linux/tips/"}],"tags":[{"name":"Case Sensitive","slug":"case-sensitive","permalink":"http://www.willychen.org/tags/case-sensitive/"},{"name":"Letter Case","slug":"letter-case","permalink":"http://www.willychen.org/tags/letter-case/"},{"name":"Vim","slug":"vim","permalink":"http://www.willychen.org/tags/vim/"}]},{"title":"UVa 442 - Matrix Chain Multiplication","slug":"uva-442-matrix-chain-multiplication","date":"2018-04-19T10:27:56.000Z","updated":"2021-09-24T11:58:20.900Z","comments":true,"path":"249/uva-442-matrix-chain-multiplication/","link":"","permalink":"http://www.willychen.org/249/uva-442-matrix-chain-multiplication/","excerpt":"這個禮拜上課時提到了 Stack 找了一題 UVa 的題目 透過 C 使用 Linked List 實作 Stack","text":"這個禮拜上課時提到了 Stack 找了一題 UVa 的題目 透過 C 使用 Linked List 實作 Stack Uva 442 Matrix Chain Multiplication 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/***************************************** Filename:p442.c Author:Willy Chen(willychen.org) Date:2018.04.19*****************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct m&#123; char name; int row; int col;&#125;;typedef struct m Matrix;struct s&#123; Matrix matrix; struct s* downPtr;&#125;;typedef struct s Stack;// Check if the stack is emptyint isEmpty(Stack **stack)&#123; if(stack == NULL) return 1; else return 0;&#125;void push(Stack **stack,Matrix matrix)&#123; //printf(&quot;Insert:%c %d %d\\n&quot;,name,row,col); Stack * new_stack = (Stack*) malloc(sizeof(Stack)); if(new_stack!=NULL)&#123; new_stack-&gt;matrix = matrix; new_stack-&gt;downPtr = (*stack); (*stack) = new_stack; &#125;&#125;// Check if stack is empty before pop functionMatrix pop(Stack **stack)&#123; Stack *top = *stack; Matrix matrix = top-&gt;matrix; *stack = (*stack)-&gt; downPtr; free(top); return matrix;&#125;;// Show the stackvoid show(Stack **stack)&#123; Stack *now = *stack; while(now!=NULL)&#123; Matrix matrix = now-&gt;matrix; printf(&quot;%c %d %d -&gt; &quot;,matrix.name,matrix.row,matrix.col); now = now-&gt;downPtr; &#125; printf(&quot;NULL\\n&quot;);&#125;int main()&#123; int num; scanf(&quot;%d\\n&quot;,&amp;num); //printf(&quot;num:%d\\n&quot;,num); Matrix matrix[30]; for(int i=0;i&lt;num;i++)&#123; char name; int row,col; scanf(&quot;%c%d%d\\n&quot;,&amp;name,&amp;row,&amp;col); matrix[i].name = name; matrix[i].row = row; matrix[i].col = col; &#125; // Show all matrices /* for(int i=0;i&lt;num;i++)&#123; printf(&quot;%c %d %d\\n&quot;,matrix[i].name,matrix[i].row,matrix[i].col); &#125; */ char command[10000]=&#123;0&#125;; while(scanf(&quot;%s&quot;,command)!=EOF)&#123; int ans=0; int flag=1; //stack of matrix Stack* stack = NULL; int len = strlen(command); for(int i=0;i&lt;len;i++)&#123; if(command[i]==&#x27;(&#x27;) continue; else if(command[i]==&#x27;)&#x27;)&#123; // Pop 2 matrices and calculate Matrix m1,m2; if(isEmpty(&amp;stack))&#123; flag=0; break; &#125;else&#123; m2 = pop(&amp;stack); &#125; if(isEmpty(&amp;stack))&#123; flag=0; break; &#125;else&#123; m1 = pop(&amp;stack); &#125; if(m1.col!=m2.row)&#123; flag=0; break; &#125; ans += m1.row*m1.col*m2.col; m1.col = m2.col; // Push the result on top of stack push(&amp;stack,m1); &#125;else&#123; // Find Matrix int j=0; for(j=0;j&lt;num;j++) if(command[i]==matrix[j].name) break; // Push Matrix on the top of stack push(&amp;stack,matrix[j]); &#125; //show(&amp;stack); &#125; if(flag) printf(&quot;%d\\n&quot;,ans); else printf(&quot;error\\n&quot;); // Reset memset(command,0,sizeof(command)/sizeof(char)); &#125; return 0;&#125;","categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"},{"name":"Linked List","slug":"linked-list","permalink":"http://www.willychen.org/tags/linked-list/"},{"name":"Stack","slug":"stack","permalink":"http://www.willychen.org/tags/stack/"}]},{"title":"Multilayer Perceptron 多層感知器","slug":"multilayer-perceptron","date":"2018-04-13T03:00:26.000Z","updated":"2021-09-24T11:58:20.899Z","comments":true,"path":"233/multilayer-perceptron/","link":"","permalink":"http://www.willychen.org/233/multilayer-perceptron/","excerpt":"最近在線性代數的課程上有提到神經網路的運作 筆者用著名的 MNIST 資料集 透過 Scikit-learn 的 MLPClassifier 來辨識數字 以下紀錄參考資料來源","text":"最近在線性代數的課程上有提到神經網路的運作 筆者用著名的 MNIST 資料集 透過 Scikit-learn 的 MLPClassifier 來辨識數字 以下紀錄參考資料來源 程式碼： Github 參考資料： Multilayer perceptron Ashing00/Multilayer-Perceptron 使用sklearn中的神经网络模块MLPClassifier处理分类问题 神經網絡快速入門：什麼是多層感知器和反向傳播？ sklearn.neural_network.MLPClassifier","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"}],"tags":[{"name":"MLPClassifier","slug":"mlpclassifier","permalink":"http://www.willychen.org/tags/mlpclassifier/"},{"name":"Multilayer Perceptron","slug":"multilayer-perceptron","permalink":"http://www.willychen.org/tags/multilayer-perceptron/"},{"name":"Scikit-learn","slug":"scikit-learn","permalink":"http://www.willychen.org/tags/scikit-learn/"}]},{"title":"Yaourt 指定 tmp 資料夾","slug":"yaourt-temporary-folder","date":"2018-04-10T04:06:18.000Z","updated":"2021-09-24T11:58:20.900Z","comments":true,"path":"242/yaourt-temporary-folder/","link":"","permalink":"http://www.willychen.org/242/yaourt-temporary-folder/","excerpt":"之前透過 yaourt 安裝 anaconda 時 因為 tmp 的大小不夠 導致安裝失敗 以下紀錄指定 tmp 資料夾的指令","text":"之前透過 yaourt 安裝 anaconda 時 因為 tmp 的大小不夠 導致安裝失敗 以下紀錄指定 tmp 資料夾的指令 注意：以下紀錄資料僅供參考，執行前請記得備份資料 查看 Linux 檔案系統的空間使用狀況 1$ df -h 使用 yaourt 時指定 tmp 資料夾 加一個 flag 就行了 （也就是只有在這次才生效，不影響其他次） 1$ yaourt --tmp &lt;dir&gt;","categories":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"}],"tags":[{"name":"Arch Linux","slug":"arch-linux","permalink":"http://www.willychen.org/tags/arch-linux/"},{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/tags/linux/"},{"name":"Install","slug":"install","permalink":"http://www.willychen.org/tags/install/"},{"name":"Yaourt","slug":"yaourt","permalink":"http://www.willychen.org/tags/yaourt/"}]},{"title":"2017 政大通識課紀錄","slug":"2017-nccu-general-education","date":"2018-03-27T02:26:18.000Z","updated":"2021-09-24T11:58:20.897Z","comments":true,"path":"213/2017-nccu-general-education/","link":"","permalink":"http://www.willychen.org/213/2017-nccu-general-education/","excerpt":"上學期有修了一些通識課程 趁著下學期開學 還大概記著上學期的通識課程 在這邊記錄下來","text":"上學期有修了一些通識課程 趁著下學期開學 還大概記著上學期的通識課程 在這邊記錄下來 以下依照星期幾上課來排序~ 圖書資訊應用 時間：一78 / mon16-18 老師：王梅玲 老師 我們是在電腦教室上課 期中考前有資料搜尋 期中考後有企劃書製作，資訊倫理等課程 會有一兩份小組報告 還有一些個人的作業 沒有期中期末考 老師同時也有開磨課師課程 若有選線上課程學期成績有加分 物理學史與人類文明 時間：二78E / tue16-19 老師：楊志開 老師 這堂課主要是講有關物理方面的歷史 當然會介紹一些物理學家 還有說一些物理方面的知識 每次上課會有一張紙條當作點名，上面有一個選擇題 內容有關剛剛上課提到的內容 會有物理計算的作業（不清楚會不會影響學期成績） 作業公佈後一周會有提示 我都在作業公佈後第二周交 之後最後一節是討論課 學期初會公佈 5 題問題 每週會有兩組同學（一組大約 6 個人）上台 就輪到的問題表達自己這組的想法 期中期末考相同 每次有選擇題 15 題 1 題學期成績 1 分 還有一題申論題學期成績 15 分 所以期中期末考加起來 60 分 都是考老師上課提到的內容 物理學家有什麼成就之類的，還有一些物理知識 電影與國際關係 時間：五78E / fri16-19 老師：蔡增家 老師 我會加簽到這堂課挺幸運的 現場加簽那天到了操場上 每 10 個人排成 1 排抽撲克牌 1 排會抽 2 個人加簽 我剛好就抽到了 這堂課主要是老師說一些國際上的事情 還有會依地區分成若干組別 像我是大洋洲組的 一學期要上台報告一次與自己組別有關的電影和內容延伸 每次上課都需要交當週國際新聞的簡介和 300 字心得 而且要與自己組別有關 所以我每個禮拜都要找有關大洋洲發生的國際新聞 每次上課老師會點人上台報告查到的新聞及自己的評論 最後一節課是助教課 會由助教替大家上課 我遇到的助教人很好，上課也很認真 還有過發點心給大家 課程中會有看電影的時候（畢竟課程名稱有電影～） 我記得期中考那一週就有看電影 期末考依照助教上的內容不同 考的東西也不一樣 期末老師會一個一個點名並看筆記 作為分數的一個依據 以上三堂課個人都有 90 分以上 有興趣的可以去選修這些課程","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"心得","slug":"學習筆記/心得","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"NCCU","slug":"nccu","permalink":"http://www.willychen.org/tags/nccu/"}]},{"title":"Computer Programming I Final Exam Problem 4 Overlapping Area","slug":"computer-programming-i-final-exam-problem-4-overlapping-area","date":"2018-03-08T09:07:16.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"225/computer-programming-i-final-exam-problem-4-overlapping-area/","link":"","permalink":"http://www.willychen.org/225/computer-programming-i-final-exam-problem-4-overlapping-area/","excerpt":"計算機程式設計1 期末考的題目4題目簡述 題目有兩個長方形，都在第一象限 輸入會先給較靠近左下角那個長方形的左下角點的 (x,y) 座標 以及給右上角點的 (x,y) 座標 輸入會再給另外一個長方形的左下角點的 (x,y) 座標 以及給右上角點的 (x,y) 座標","text":"計算機程式設計1 期末考的題目4題目簡述 題目有兩個長方形，都在第一象限 輸入會先給較靠近左下角那個長方形的左下角點的 (x,y) 座標 以及給右上角點的 (x,y) 座標 輸入會再給另外一個長方形的左下角點的 (x,y) 座標 以及給右上角點的 (x,y) 座標 題目輸出 印出兩個長方形的重疊面積 解題想法 先檢查有無重疊，沒有重疊就印出 0，有重疊就算出面積 程式碼123456789101112131415161718192021222324/***************************************** Filename:cp1_final_p4.c Author:Willy Chen(willychen.org) Date:2018.03.08*****************************************/#include&lt;stdio.h&gt;int main()&#123; int x1,y1,x2,y2; int x3,y3,x4,y4; int x=0,y=0; scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); scanf(&quot;%d %d %d %d&quot;,&amp;x3,&amp;y3,&amp;x4,&amp;y4); /* Check if the two rectangles are overlapping */ if(x3&gt;x2||y3&gt;y2)&#123; printf(&quot;0\\n&quot;); return 0; &#125; /* Calculate overlapping area */ x = x2-x3; y = y2-y3; printf(&quot;%d\\n&quot;,x*y); return 0;&#125;","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Assignment","slug":"assignment","permalink":"http://www.willychen.org/tags/assignment/"}]},{"title":"Gnome Shell Alt+Tab 切換視窗設定","slug":"gnome-shell-alt-tab-switch-windows","date":"2018-02-27T10:59:22.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"205/gnome-shell-alt-tab-switch-windows/","link":"","permalink":"http://www.willychen.org/205/gnome-shell-alt-tab-switch-windows/","excerpt":"筆者在使用 Windows 系統時會使用 Alt+Tab 來切換到不同的視窗 而在使用 Linux 與 Gnome Shell 時 在按下 Alt+Tab 時也是會顯示每個視窗縮圖 但是同一個應用程式會變成一個群組","text":"筆者在使用 Windows 系統時會使用 Alt+Tab 來切換到不同的視窗 而在使用 Linux 與 Gnome Shell 時 在按下 Alt+Tab 時也是會顯示每個視窗縮圖 但是同一個應用程式會變成一個群組 以前筆者都會用滑鼠去點選群組中所要的視窗 今天查詢了資料 修改成每個應用程式的不同視窗會分開顯示 透過 Alt+Tab 來切換 注意：以下紀錄資料僅供參考，執行前請記得備份資料 資料參考來源：How to prevent Gnome-shell’s Alt+Tab from grouping windows from similar apps? 打開 Settings 應用程式 左邊的欄位選擇 Devices → Keyboard 這個部份可能會因版本的不同而在不同的地方 基本上就是找到可以設定鍵盤按鍵的地方 找到 Switch windows 在右邊的鍵盤按鍵設定列表中尋找 Switch windows 這個選項 點擊後會要求按下欲綁定的按鍵 我們按下 Alt-Tab 後 就設定完成了 或是程式可能跳出是否要取代 Switch applications （因為按鍵重複了） 按 Replace 後就設定完成了 接下來就可以查看 Switch windows 的選項有沒有綁定 Alt+Tab並且實際按 Alt-Tab 看是否設定成功了~","categories":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/tags/linux/"},{"name":"Gnome-Shell","slug":"gnome-shell","permalink":"http://www.willychen.org/tags/gnome-shell/"}]},{"title":"在重新分割硬碟後修正grub設定","slug":"fix-grub-config-after-resizing-partition","date":"2018-02-10T04:33:48.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"194/fix-grub-config-after-resizing-partition/","link":"","permalink":"http://www.willychen.org/194/fix-grub-config-after-resizing-partition/","excerpt":"幾天前透過 Windows 的磁碟管理工具弄了新的分區 之後重新開機後進入 Grub 選單時出現了以下文字： 12error: unknown filesystem.grub rescue&gt; 可能是因為重新分割硬碟後 分區代號沒有更新導致問題 以下紀錄如何修正","text":"幾天前透過 Windows 的磁碟管理工具弄了新的分區 之後重新開機後進入 Grub 選單時出現了以下文字： 12error: unknown filesystem.grub rescue&gt; 可能是因為重新分割硬碟後 分區代號沒有更新導致問題 以下紀錄如何修正 注意：以下紀錄資料僅供參考，執行前請記得備份資料 基本上依照安裝 Arch Linux 的流程重新設定 fstab 和 grub 就可以了 插入 Arch Linux 安裝隨身碟，在 BIOS 時選擇隨身碟開機 （一般來說開機按鈕按下後，按 F12 可以選擇） 選第一個選項 Arch Linux archiso x86_64 UEFI USB 進入 Shell 查看磁碟分割 1$ gdisk -l /dev/nvme0n1 筆者電腦使用 SSD，所以是 nvme0n1，用 HDD 的會是 sda1 指令輸入後會出現分區的資料，找出 EFI 分區和 Linux 系統分區 以下假設 EFI 分區在 /dev/nvme0n1p3 ，Linux 系統分區在 /dev/nvme0n1p5 mount 12$ mount /dev/nvme0n1p5 /mnt$ mount /dev/nvme0n1p3 /mnt/boot/efi 更新 fstab 123$ # You can backup fstab file, or remove the file$ mv /mnt/etc/fstab /mnt/etc/fstab.b$ genfstab -p /mnt &gt;&gt; /mnt/etc/fstab 進入 chroot 1$ arch-chroot /mnt 設定 grub 12$ grub-mkconfig$ grub-install boot/efi 退出後重開機 1234$ exit$ umount /mnt/boot/efi$ umount /mnt$ reboot 接下來就可以查看 grub 是否可以正常使用了","categories":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"}],"tags":[{"name":"Arch Linux","slug":"arch-linux","permalink":"http://www.willychen.org/tags/arch-linux/"},{"name":"Grub","slug":"grub","permalink":"http://www.willychen.org/tags/grub/"},{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/tags/linux/"}]},{"title":"在 Arch Linux 安裝 Hime","slug":"install-hime-on-arch-linux","date":"2018-01-31T10:26:31.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"165/install-hime-on-arch-linux/","link":"","permalink":"http://www.willychen.org/165/install-hime-on-arch-linux/","excerpt":"在之前使用 Ubuntu 時就有使用過 Hime 輸入法 在使用 Arch Linux 後也會在安裝完系統後安裝這個輸入法 以下紀錄安裝的過程","text":"在之前使用 Ubuntu 時就有使用過 Hime 輸入法 在使用 Arch Linux 後也會在安裝完系統後安裝這個輸入法 以下紀錄安裝的過程 注意：以下紀錄資料僅供參考，執行前請記得備份資料 Hime Github : https://github.com/hime-ime/hime 安裝 Hime 12$ # Package Details : https://aur.archlinux.org/packages/hime-git/$ yaourt -S hime-git 將以下程式碼加入家目錄下的 .xprofile 12345678910$ vim ~/.xprofile----- .xprofile -----export XIM_PROGRAM=himeexport XIM=himeexport GTK\\_IM\\_MODULE=himeexport QT\\_IM\\_MODULE=himeexport XMODIFIERS=@im=himehime &amp;--------------------- 重新登入並設定 Hime ，完成 （找到 Hime 的程式打開應該會有圖形化介面可以設定） 補充： 筆者使用 GDM 來管理圖形環境，及使用 Gnome 來作為桌面環境 本來是預設使用 Xorg 來登入 但在某一個版本更新後貌似會使用 Wayland 來登入 導致登入時不會去讀取剛剛設定的 .xprofile 的內容 Hime 進而無法使用 筆者測試後找到了兩個暫時的解決方案如下： 方案一： 將 .xprofile 的內容複製到 /etc/environment 中（記得要root權限）然後重新登入只是由於我們有設定 GTK\\_IM\\_MODULE不知道為什麼會有一些程式（如 gnome-terminal）無法成功啟動（換句話說，可以把 GTK\\_IM\\_MODULE 註解或刪除一些程式應該可以正常啟動，只是這些使用 GTK 的程式可能就無法使用 Hime） 2018.03.30 更新：筆者在 Wayland 測試時無法成功啟動 Hime 輸入法先暫時刪除 方案二： 在登入時，右下角有一個齒輪圖案點擊後可以選擇 GNOME on Xorg再登入就可以正常使用 Hime只是 Wayland 的功能就會無法使用","categories":[{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"}],"tags":[{"name":"Arch Linux","slug":"arch-linux","permalink":"http://www.willychen.org/tags/arch-linux/"},{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/tags/linux/"},{"name":"Hime","slug":"hime","permalink":"http://www.willychen.org/tags/hime/"},{"name":"Install","slug":"install","permalink":"http://www.willychen.org/tags/install/"}]},{"title":"Computer Programming I Assignment 5 Bot Maze","slug":"computer-programming-i-assignment-5-bot-maze","date":"2018-01-26T13:17:43.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"167/computer-programming-i-assignment-5-bot-maze/","link":"","permalink":"http://www.willychen.org/167/computer-programming-i-assignment-5-bot-maze/","excerpt":"計算機程式設計1 的作業5 – 走迷宮題目簡述 有一4×4迷宮，起點在(0,0)，終點在(3,0) 迷宮中可能會有障礙物 從起點到終點，每一格都需走過剛好一遍","text":"計算機程式設計1 的作業5 – 走迷宮題目簡述 有一4×4迷宮，起點在(0,0)，終點在(3,0) 迷宮中可能會有障礙物 從起點到終點，每一格都需走過剛好一遍 題目輸出 印出總共有幾種走法 解題想法 迷宮並沒有很大 可利用深度優先搜尋法(Depth First Search)把整個地圖走過 程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/***************************************** Filename:cp1_hw5.c Author:Willy Chen(willychen.org) Date:2018.01.26*****************************************/#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#define ROW 4+1#define COLUMN 4+1void DFS(bool maze[COLUMN][ROW],int *path,int x,int y,int start)&#123; /* jumps out-of-bounds */ if(x&lt;0||y&lt;0||x==COLUMN-1||y==ROW-1) return; /* check all the places have been jumped */ if(x==3&amp;&amp;y==0)&#123; int count=0; for(int i=0;i&lt;ROW-1;i++)&#123; for(int j=0;j&lt;COLUMN-1;j++)&#123; if(maze[i][j]==false) count++; &#125; &#125; if(!count)&#123; (*path)++; return; &#125; return; &#125; /* the place has been jumped */ if(maze[x][y]==true&amp;&amp;start==true) return; maze[x][y]=true; /* jumps up, down, right, left */ DFS(maze,path,x+1,y,true); DFS(maze,path,x-1,y,true); DFS(maze,path,x,y+1,true); DFS(maze,path,x,y-1,true); if(maze[x][y]==true&amp;&amp;start==true) maze[x][y]=false; return;&#125;int main()&#123; bool maze[COLUMN][ROW]=&#123;0&#125;; /* input the map */ for(int i=0; i&lt;COLUMN; i++)&#123; for(int j=0; j&lt;ROW; j++)&#123; maze[i][j]=false; &#125; &#125; /* obstacle location */ int x,y; while(scanf(&quot;%d,%d&quot;,&amp;x,&amp;y)!=EOF)&#123; maze[x][y]=true; &#125; maze[0][0]=true; maze[3][0]=true; int path =0; /* calculate the paths */ DFS(maze,&amp;path,0,0,false); printf(&quot;path:%d\\n&quot;,path); return 0;&#125;","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Assignment","slug":"assignment","permalink":"http://www.willychen.org/tags/assignment/"}]},{"title":"Computer Programming I Assignment 4 Hopscotch","slug":"computer-programming-i-assignment-4-hopscotch","date":"2018-01-16T07:08:24.000Z","updated":"2021-09-24T17:27:46.873Z","comments":true,"path":"141/computer-programming-i-assignment-4-hopscotch/","link":"","permalink":"http://www.willychen.org/141/computer-programming-i-assignment-4-hopscotch/","excerpt":"計算機程式設計1 的作業4 - 跳格子題目簡述 輸入會給總共要跳幾格 一次可以跳1~4格，只能往前跳 若總共跳10格已內，最多跳7次；總共跳11~20格，最多跳17次；總共跳21~30格，最多跳27次 跳的步數從最小排序，如：(1,1,3), (1,3,1), (3,1,1) 都視為是 (1,1,3)（算同一種跳法）","text":"計算機程式設計1 的作業4 - 跳格子題目簡述 輸入會給總共要跳幾格 一次可以跳1~4格，只能往前跳 若總共跳10格已內，最多跳7次；總共跳11~20格，最多跳17次；總共跳21~30格，最多跳27次 跳的步數從最小排序，如：(1,1,3), (1,3,1), (3,1,1) 都視為是 (1,1,3)（算同一種跳法） 題目輸出 印出有幾種跳法 解題想法 基本上是一個遞迴的題目，可以從上面往下拆或是從下面往上加 從上往下拆 假設左邊的步數應該大於等於右邊的步數（就是只拆左邊） 以跳 5 格為例 所以 return 的順序應該為： (1,1,1,1,1) (2,1,1,1) (3,1,1) (2,2,1) (4,1) (3,2) 注意有一個 min 去紀錄正在計算的那一步是否有大於 min，避免重複計算排序錯誤的跳法 如紅色星號地方，min為 2，但是因為 right 小於 2，所以 return 0，就是避免算到 (2,1,2) 123456789101112131415161718192021222324252627282930313233343536373839/***************************************** Filename:cp1_hw4_1.c Author:Willy Chen(willychen.org) Date:2018.01.15*****************************************/#include &lt;stdio.h&gt;int hop(int,int,int,int); /*prototype*/int main(void)&#123; int answer1; int pos=0; while(scanf(&quot;%d&quot;,&amp;pos)!=EOF)&#123; if(pos&lt;=10) answer1 = hop(pos,0,pos,7); else if (pos&gt;10&amp;&amp;pos&lt;=20) answer1 = hop(pos,0,pos,17); else if(pos&gt;20&amp;&amp;pos&lt;=30) answer1 = hop(pos,0,pos,27); printf(&quot;%d\\n&quot;, answer1); &#125; return 0;&#125;int hop(int left,int right,int min,int step)&#123; int jump=0; if(step==0) /*you have no more steps*/ return 0; if(right!=0) if(left &lt; min || right &lt; min) /*check if the left and right are smaller than min*/ return 0; if(left==1&amp;&amp;right==1) return 1; for(int i=left-1;i&gt;=left/2&amp;&amp;i&gt;=left-i;i--)&#123; if(right==0) right=left-i; jump += hop(i,left-i,right,step-1); &#125; if(left&lt;=4&amp;&amp;right&lt;=4) /*this jump should also be calculated*/ jump++; return jump;&#125; 從下往上加 從 1 開始一步一步測試 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/***************************************** Filename:cp1_hw4_2.c Author:Willy Chen(willychen.org) Date:2018.01.15*****************************************/#include &lt;stdio.h&gt;int hop(int,int,int,int,int,int); /*prototype*/int main(void)&#123; int answer1=0; int input; while(scanf(&quot;%d&quot;,&amp;input)!=EOF)&#123; answer1=0; int step; switch(input)&#123; case 1 ... 10: step=7; break; case 11 ... 20: step=17; break; case 21 ... 30: step=27; break; &#125; for(int i=1;i&lt;=4;i++) answer1 += hop(input,0,i,1,step,0); printf(&quot;%d\\n&quot;, answer1); &#125; return 0;&#125;int hop(int all,int now,int add,int step,int maxn_step,int min)&#123; int ans = 0; if(step&gt;maxn_step) /*you have no more steps*/ return 0; if(add&lt;min) /*check if the add is smaller than min*/ return 0; now += add; if(now&gt;all) return 0; if(all==now)&#123; ans++; return ans; &#125; for(int i=1;i&lt;=4;i++) ans += hop(all,now,i,step+1,maxn_step,add); return ans;&#125;","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Assignment","slug":"assignment","permalink":"http://www.willychen.org/tags/assignment/"}]},{"title":"C語言 Pointer 指標","slug":"c-pointer","date":"2018-01-03T14:56:40.000Z","updated":"2021-09-24T11:58:20.898Z","comments":true,"path":"33/c-pointer/","link":"","permalink":"http://www.willychen.org/33/c-pointer/","excerpt":"C語言的重要功能之一：指標，以下簡單紀錄","text":"C語言的重要功能之一：指標，以下簡單紀錄 特色 傳參考(Call By Reference) 值是儲存地址(Memory Address) 宣告(declaration) 1int *ptr; 初始化(initialization) 1234567int num=0;ptr = &amp;num; //將num所在地址存到變數ptr當中ptr = NULL; //ptr不會指到任何東西ptr = 0; //和NULL一樣，但建議使用NULL 反參考(dereference) 取得指標指向的記憶體中那個變數所存的值 1printf(&quot;%d&quot;,*ptr); 範例程式 12345678910111213141516/***************************************** Filename:Pointer1.c Author:Willy Chen(willychen.org) Date:2018.01.03*****************************************/#include&lt;stdio.h&gt;int main(void)&#123; int num=0; int *ptr = &amp;num; printf(&quot;ptr: %p\\\\n&quot;,ptr); //Address of num printf(&quot;\\*ptr: %d\\\\n&quot;,\\*ptr); //Value of num printf(&quot;&amp;num: %p\\\\n&quot;,&amp;num); //Address of num printf(&quot;&amp;\\*ptr: %p\\\\n&quot;,&amp;\\*ptr); //Address of num return 0;&#125; 1234ptr: 0x7ffc2dc851fc*ptr: 0&amp;num: 0x7ffc2dc851fc&amp;*ptr: 0x7ffc2dc851fc 傳地址(call by reference) Function的參數都是透過傳值(call by value) 透過指標，可以「模擬」傳地址(call by reference) 12345678910111213141516171819202122/***************************************** Filename:Pointer2.c Author:Willy Chen(willychen.org) Date:2018.01.03*****************************************/#include&lt;stdio.h&gt;void square(int *ptr); //prototypeint main(void)&#123; int num=2; printf(&quot;Origin num: %d\\\\n&quot;,num); square(&amp;num); printf(&quot;New num: %d\\\\n&quot;,num); return 0;&#125;void square(int *ptr)&#123; \\*ptr = \\*ptr * *ptr;&#125;Origin num: 2New num: 4 指標與陣列 1234567891011121314151617181920212223242526/***************************************** Filename:Pointer3.c Author:Willy Chen(willychen.org) Date:2018.01.03*****************************************/#include&lt;stdio.h&gt;int main()&#123; int a\\[5\\]=&#123;0&#125;; int \\*ptr = &amp;a\\[0\\]; //也可以寫成 int \\*ptr = a; int *ptr2 = NULL; printf(&quot;address of a\\[0\\]:%p\\\\n&quot;,&amp;a\\[0\\]); printf(&quot;value of ptr:%p\\\\n&quot;,ptr); //value of ptr = the address of a\\[0\\] ptr += 2; printf(&quot;address of a\\[2\\]:%p\\\\n&quot;,&amp;a\\[2\\]); printf(&quot;value of ptr:%p\\\\n&quot;,ptr); //value of ptr = the address of a\\[2\\] ptr2 = &amp;a\\[4\\]; printf(&quot;value of ptr2-ptr:%d\\\\n&quot;,ptr2-ptr); //the number of array elements from ptr to ptr2 return 0;&#125; 12345address of a\\[0\\]:0x7fff77e371d0value of ptr:0x7fff77e371d0address of a\\[2\\]:0x7fff77e371d8value of ptr:0x7fff77e371d8value of ptr2-ptr:2 當 ptr 指向a[0]，地址(…1d0)則 ptr+2 會指向a[2]，地址(…1d0) + 2 × 4 ⇐ 乘4是因為1個int佔4個Bytes所以 ptr+2 指向地址(…1d8)，也就是a[2]的地址 而 ptr2-ptr 會回傳地址差÷4就是 ( (…1e6) - (…1d8) ) ÷ 4 = 2 void1void *ptr; 可以使用void來宣告pointer，此pointer只存地址 此類pointer不可反參考 若要反參考，須將此pointer轉型至int等型別 const with pointer non-constant pointer，non-constant data pointer可以改指其他地址，反參考(dereferenced)可以改存的資料 non-constant pointer，constant data pointer可以改指其他地址，但反參考不能改存的資料 1234567891011121314151617181920212223/***************************************** Filename:Pointer4.c Author:Willy Chen(willychen.org) Date:2018.01.04*****************************************/#include&lt;stdio.h&gt;void printChar( const char *Ptr);// 等同於 void printChar( char const *Ptr);int main()&#123; char s\\[\\]=&quot;This is a test.&quot;; printf(&quot;s:%s\\\\n&quot;,s); printChar(s); printf(&quot;\\\\n&quot;); return 0;&#125;void printChar( const char *Ptr)&#123; for(; *Ptr != &#x27;\\\\0&#x27;;Ptr++)&#123; printf(&quot;%c&quot;,*Ptr); &#125;&#125; 12s:This is a test.This is a test. 在 printChar 中只有讀取 Ptr 的值，然後修改 Ptr 的指向，並沒有修改 Ptr 所指變數的值 若是在 printChar 的 for 迴圈中加個 *Ptr = ‘x’; 之類的 compiler 會印出 Error，因為加 const 設定成 read-only了 constant pointer，non-constant data pointer永遠指向同一地址，反參考(dereferenced)可以改存的資料 宣告一個array時預設的權限：array的名稱恆指向陣列的開頭 123456789101112131415161718192021/***************************************** Filename:Pointer5.c Author:Willy Chen(willychen.org) Date:2018.01.05*****************************************/#include&lt;stdio.h&gt;void change( char * const Ptr);int main()&#123; char c = &#x27;A&#x27;; char *cptr = &amp;c; printf(&quot;Origin:%c\\\\n&quot;,*cptr); //deference change(cptr); printf(&quot;Change:%c\\\\n&quot;,*cptr); return 0;&#125;void change( char * const Ptr)&#123; *Ptr = &#x27;B&#x27;;&#125; 12Origin:AChange:B constant pointer，constant data pointer恆指向同一地址，那個地址中的資料不可用反參考修改 基本上只能做讀取的功能 1void read( const char * const ptr) 如傳一個 array 到 Function 中時，Function中只能對此 array 做讀取的動作 簡單整理一下 當有 const 在 * 左邊時，代表這個 pointer 指向地址存的資料不可更動，如 12const char * c;char const * c; 當有 const 在 * 右邊時，代表這個 pointer 不可變更指向的地址，如 1char * const c; sizeof operator 是一種一元運算子(unary operator) 使用 sizeof 讓程式在編譯時取得變數(陣列等等)的 byte 大小 範例程式 1234567891011121314151617181920212223242526/***************************************** Filename:Pointer6.c Author:Willy Chen(willychen.org) Date:2018.01.05*****************************************/#include&lt;stdio.h&gt;int main()&#123; int x = 0; char y = 0; double z = 0; char *ptr = &amp;y; printf(&quot;size of x:%d\\\\n&quot; &quot;size of int:%d\\\\n&quot; &quot;size of y:%d\\\\n&quot; &quot;size of char:%d\\\\n&quot; &quot;size of z:%d\\\\n&quot; &quot;size of double:%d\\\\n&quot; &quot;size of ptr:%d\\\\n&quot; &quot;size of char*:%d\\\\n&quot;, sizeof(x),sizeof(int),sizeof(y),sizeof(char), sizeof(z),sizeof(double),sizeof(ptr),sizeof(char*) ); return 0;&#125; 12345678size of x:4size of int:4size of y:1size of char:1size of z:8size of double:8size of ptr:8size of char*:8 結果可以看到存 char* (char的指標)使用了 8 bytes Array of pointer 可以宣告一個指標陣列，其中存一些字串(正確來說是存指標) 1234567891011121314151617/***************************************** Filename:Pointer7.c Author:Willy Chen(willychen.org) Date:2018.01.05*****************************************/#include&lt;stdio.h&gt;int main()&#123; const char * array\\[4\\] = &#123;&quot;Apple&quot;,&quot;Banana&quot;,&quot;Lemon&quot;,&quot;Orange&quot;&#125;; printf(&quot;array\\[0\\]:%s\\\\n&quot;,array\\[0\\]); printf(&quot;array\\[1\\]:%s\\\\n&quot;,array\\[1\\]); printf(&quot;\\*array\\[0\\]:%c\\\\n&quot;,\\*array\\[0\\]); printf(&quot;\\*array\\[1\\]:%c\\\\n&quot;,\\*array\\[1\\]); printf(&quot;size of array:%d\\\\n&quot;,sizeof(array)); printf(&quot;elements of array:%d\\\\n&quot;,sizeof(array)/sizeof(char*)); return 0;&#125; 123456array\\[0\\]:Applearray\\[1\\]:Banana*array\\[0\\]:A*array\\[1\\]:Bsize of array:32elements of array:4 範例程式中array 是一個存有4個指標的陣列 第一個指標 array[0] 指向第一個字串第一個字元的地址，也就是”Apple”的’A’ 第二個指標 array[1] 指向第二個字串第一個字元的地址，也就是”Banana”的’B’ 所以當反參考 *array[0] 時，會得到 ‘A’ 反參考 *array[1] 時，會得到 ‘B’ 注意字串 “Apple” 實際上是存 ‘A’ ‘p’ ‘p’ ‘l’ ‘e’ ‘\\0’，每個字串後面都有 ‘\\0’ (null-terminated character string) sizeof(array)會回傳陣列的大小(Bytes) 使用 sizeof(array)/sizeof(char*) 可以得到 array 的元素個數：4 換句話說，前面有得到 指標的大小sizeof(char*) 是占用 8 bytes，而 array 有4個元素，所以 array的大小就是 8 × 4 = 32 ，也就是 sizeof(array) 得到的數值 pointer to function 剛剛是指到字串的地址，現在換成指到 function 的 定義： void (*f[3]) (int) = {func1, func2, func3}; 有三個 function 叫 func1，func2 和 func3，其中他們的回傳值是 void，有一個 int 的參數 現在把他們放到一個叫 f[3] 的指標陣列當中，f[0]，f[1]，f[2] 都是一個指標 使用： (*f[element]) (argument); (*f[element]) 是對指標進行反參考，所以 f[0] 對應 func1，f[1] 對應 func2，f[2] 對應 func3 (argument) 就是傳參數進去 注意：上面用紅色標註的括號是不能缺少的，一定要寫 範例程式 12345678910111213141516171819202122232425262728/***************************************** Filename:Pointer8.c Author:Willy Chen(willychen.org) Date:2018.01.05*****************************************/#include&lt;stdio.h&gt;void func1(int x)&#123; printf(&quot;1:%d\\\\n&quot;,x);&#125;void func2(int y)&#123; printf(&quot;2:%d\\\\n&quot;,y);&#125;void func3(int z)&#123; printf(&quot;3:%d\\\\n&quot;,z);&#125;int main()&#123; void (*f\\[3\\]) (int) = &#123;func1, func2, func3&#125;; int input = 100; (*f\\[0\\])(input); (*f\\[1\\])(input); (*f\\[2\\])(input); return 0;&#125; 1231:1002:1003:100","categories":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"Pointer","slug":"pointer","permalink":"http://www.willychen.org/tags/pointer/"}]}],"categories":[{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/categories/uva/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"心得","slug":"學習筆記/心得","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E5%BF%83%E5%BE%97/"},{"name":"計算機程式設計","slug":"學習筆記/計算機程式設計","permalink":"http://www.willychen.org/categories/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"Tips","slug":"tips","permalink":"http://www.willychen.org/categories/tips/"},{"name":"其他","slug":"其他","permalink":"http://www.willychen.org/categories/%E5%85%B6%E4%BB%96/"},{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/categories/linux/"},{"name":"Tips","slug":"linux/tips","permalink":"http://www.willychen.org/categories/linux/tips/"}],"tags":[{"name":"C/C++","slug":"c-c","permalink":"http://www.willychen.org/tags/c-c/"},{"name":"UVa","slug":"uva","permalink":"http://www.willychen.org/tags/uva/"},{"name":"Data Structure","slug":"data-structure","permalink":"http://www.willychen.org/tags/data-structure/"},{"name":"Binary Tree","slug":"binary-tree","permalink":"http://www.willychen.org/tags/binary-tree/"},{"name":"Full Binary Tree","slug":"full-binary-tree","permalink":"http://www.willychen.org/tags/full-binary-tree/"},{"name":"Algorithm","slug":"algorithm","permalink":"http://www.willychen.org/tags/algorithm/"},{"name":"Longest Common Subsequence","slug":"longest-common-subsequence","permalink":"http://www.willychen.org/tags/longest-common-subsequence/"},{"name":"Edit Distance","slug":"edit-distance","permalink":"http://www.willychen.org/tags/edit-distance/"},{"name":"Dynamic Programming","slug":"dynamic-programming","permalink":"http://www.willychen.org/tags/dynamic-programming/"},{"name":"All-Pairs Shortest Path","slug":"all-pairs-shortest-path","permalink":"http://www.willychen.org/tags/all-pairs-shortest-path/"},{"name":"Floyd–Warshall algorithm","slug":"floyd–warshall-algorithm","permalink":"http://www.willychen.org/tags/floyd%E2%80%93warshall-algorithm/"},{"name":"Sort","slug":"sort","permalink":"http://www.willychen.org/tags/sort/"},{"name":"Merge Sort","slug":"merge-sort","permalink":"http://www.willychen.org/tags/merge-sort/"},{"name":"NCCU","slug":"nccu","permalink":"http://www.willychen.org/tags/nccu/"},{"name":"Assignment","slug":"assignment","permalink":"http://www.willychen.org/tags/assignment/"},{"name":"LeetCode","slug":"leetcode","permalink":"http://www.willychen.org/tags/leetcode/"},{"name":"Basis","slug":"basis","permalink":"http://www.willychen.org/tags/basis/"},{"name":"Linear Algebra","slug":"linear-algebra","permalink":"http://www.willychen.org/tags/linear-algebra/"},{"name":"XOR","slug":"xor","permalink":"http://www.willychen.org/tags/xor/"},{"name":"Bios","slug":"bios","permalink":"http://www.willychen.org/tags/bios/"},{"name":"Fn Key","slug":"fn-key","permalink":"http://www.willychen.org/tags/fn-key/"},{"name":"Lenovo Yoga","slug":"lenovo-yoga","permalink":"http://www.willychen.org/tags/lenovo-yoga/"},{"name":"Case Sensitive","slug":"case-sensitive","permalink":"http://www.willychen.org/tags/case-sensitive/"},{"name":"Letter Case","slug":"letter-case","permalink":"http://www.willychen.org/tags/letter-case/"},{"name":"Vim","slug":"vim","permalink":"http://www.willychen.org/tags/vim/"},{"name":"Linked List","slug":"linked-list","permalink":"http://www.willychen.org/tags/linked-list/"},{"name":"Stack","slug":"stack","permalink":"http://www.willychen.org/tags/stack/"},{"name":"MLPClassifier","slug":"mlpclassifier","permalink":"http://www.willychen.org/tags/mlpclassifier/"},{"name":"Multilayer Perceptron","slug":"multilayer-perceptron","permalink":"http://www.willychen.org/tags/multilayer-perceptron/"},{"name":"Scikit-learn","slug":"scikit-learn","permalink":"http://www.willychen.org/tags/scikit-learn/"},{"name":"Arch Linux","slug":"arch-linux","permalink":"http://www.willychen.org/tags/arch-linux/"},{"name":"Linux","slug":"linux","permalink":"http://www.willychen.org/tags/linux/"},{"name":"Install","slug":"install","permalink":"http://www.willychen.org/tags/install/"},{"name":"Yaourt","slug":"yaourt","permalink":"http://www.willychen.org/tags/yaourt/"},{"name":"Gnome-Shell","slug":"gnome-shell","permalink":"http://www.willychen.org/tags/gnome-shell/"},{"name":"Grub","slug":"grub","permalink":"http://www.willychen.org/tags/grub/"},{"name":"Hime","slug":"hime","permalink":"http://www.willychen.org/tags/hime/"},{"name":"Pointer","slug":"pointer","permalink":"http://www.willychen.org/tags/pointer/"}]}